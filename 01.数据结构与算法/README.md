## 数据结构与算法
- <a href="#sjfz">时间复杂度</a>
- <a href="#kjfz">空间复杂度</a>
- 数据结构  
    - <a href="#ljjg">逻辑结构</a>
    - <a href="#ccjg">存储结构</a>
    - 数据结构-二叉树   
        - 二叉树遍历
        - 二叉树的对称性
        - 二叉搜索树
        - 二叉树的深度
    - 数据结构-链表   
        - 基本应用
        - 环类题目
        - 双指针
        - 双向链表
    - 数据结构-数组   
        - 双指针
        - N数之和问题
        - 二维数组
        - 数据统计
    - 数据结构-栈和队列
    - 数据结构-哈希表
    - 数据结构-堆
- 算法
    - 排序
    - 二分查找
    - 递归
        - 重复计算
        - 广度优先搜索
        - 深度优先搜索
        - 回溯算法
        - 动态规划
    - 贪心算法


    ### <a id="ljjg">逻辑结构</a>
    >数据逻辑结构是指数据之间的逻辑关系的描述
    可分为四类基本结构
    - 集合结构：结构中的数据元素之间除了同属一个集合外无任何关系
    - 线性结构：结构中的数据元素存在着一对一的线性关系
    - 树形结构：结构中的数据元素存在着一对多的层次关系
    - 图状结构或网状结构：结构中的数据元素存在着对于多的任意关系

    ### <a id="ccjg">存储结构</a>
    > 逻辑结构在计算机中的存储映像，是逻辑结构在计算机中的实现。它包括数据元素的表示和关系的表示。
    常见的存储结构有
    - 顺序存储：存储位置紧邻
    - 链式存储：逻辑关系紧邻，存储地址不相邻

    ### <a id="sjfz">时间复杂度</a>

    Q： 一枚1元硬币，分为1分、2分、5分硬币共50枚应该如何去分   

    A： 先把公式写出来 `x+y+z=50 x+2y+5z=100`

    ```
    for (let i = 0;i <= 50; i++) {
        for (let j = 0;j <= 50; j++) {
            for (let k = 0;k <= 50; k++) {
                if((i+j+k==50)&&(i+2*j+5*k==100)) {
                    console.log(i, j, k);
                }
            }
        }
    }
    ```
    结果是得到了。但是可以看到此方法用了三重循环，所以基本的判断操作共执行了`51*51*51`次   

    那想要执行次数少些要怎么做那

    ```
    for (let i = 0; i <= 50; i++) {
        for(let j = 0; j <= 50; j++) {
            let k = 50 - i - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }
    ```

    第二种方法总共执行了`51*51`次，明显运行频率要低于第一种，但还是存在着优化的空间

    先梳理下思路，因为是1元硬币所以5分硬币不会超过20个

    ```
    for(let k = 0; k <= 20; k++) {
        for(let j = 0; j <= 50; j++) {
            let i = 50 - k - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }

    ```

    此次循环次数为`21 * 51`次，又提高了运行效率，那可不可以只循环一次那   
    思路：根据 `x+y+z=50 x+2y+5z=100` 可得 y+4z = 50; 并且z最大不能超过12
    ```
    for(let k = 0; k < 13; k++) {
        let j = 50 - 4*k;
        let i = 50 - k - j;
        if((i+j+k==50)&&(i+2*j+5*k==100)) {
            console.log(i, j, k);
        }
    }
    ```

    此时循环次数为13  
    根据以上案例可以得出规律，所有代码的执行时间与每行代码的执行次数成正比
    用公式表达为`T(n) = O(f(n))`   
    其中T(n)代表代码执行的时间，n表示数据规模的大小，f(n)表示每行代码执行的次数总和，
    因为是个公式所以用f(n)来表示。该公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。      
    需要注意的是大O时间复杂度不具体表示代码真正的执行时间，而是表示代码的执行时间随数据的规模增长的变化趋势，所以也叫渐进时间复杂度，简称为时间复杂度，要认清`T(n) = O(1)`并不是代码只执行了一次 。         
    由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项   
    
    对于上述例子中第一种三重循环对应的时间复杂度为O(n³);   
    二重循环的时间复杂度为O(n^2)   
    单重循环的时间复杂度为O(n)，也叫线性阶。   
    对于没有循环语句的算法，记作O(1)，也称为常数阶   

    可见算法的设计尤为关键。

    再来看几个例子

    ```
    function test(n) {
        for(let i=0; i < 10; i++) {
            console.log(i);
        }
        for(let j = 0; j < n; j++) {
            console.log(j)
        }
        for(let z = 0; z < n; z++) {
            for (let x = 0; x < n; x++) {
                console.log(x);
            }
        }
    }
    ```
    在test函数中 可以看到第一个循环的时间复杂度O(1)，是一个常量的执行时间，跟n的规模无关;
    第二个循环的时间复杂度为O(n)
    第三个嵌套循环的时间复杂度为O(n^2)   

    根据这三段代码我们取其中最大的量级，总的时间复杂度为量级最大的时间复杂度O(n^2)

    我们来改变下代码
    ```
        function test(n) {
            for(let i=0; i < n; i++) {
            var sum = i + test2(i);
                console.log(sum);
            }
        }
        function test2(n) {
            let sum = 0;
            for(let i=0; i < n; i++) {
                sum = i + sum;
            }
            return sum;
        }
    ```
    在test函数中 如果test2只是一个简单操作，那么test中的for循环的时间复杂度为O(n).      
    但test2并不是一个简单操作，他的时间复杂的为O(n),所以整个test的时间复杂度需要相乘为O(n^2)

    ### <a id="kjfz">空间复杂度</a>   
    空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。
    ```
    function test(n) {
        var i = 0;
        var j = new Array(n);
    }
    ```
    在此段代码中申请了空间存储变量i，但是它是常量阶的，跟数据规模n没有关系所以空间复杂度为O(1)    
    接下来我们申请了大小为n的数组，所以整段代码的空间复杂度为O(n)   
    间复杂度分析比时间复杂度分析要简单的多，所以这里不再过多举例陈述。明白其中的概念意义即可。




## 优秀博文

<a href="https://juejin.im/post/5d5b307b5188253da24d3cd1">前端该如何准备数据结构和算法</a>   
<a href="https://juejin.im/post/5cd1ab3df265da03587c142a?utm_source=gold_browser_extension#heading-7">窥探数据结构的世界</a>
