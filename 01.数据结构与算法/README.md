# 数据结构与算法
- <a href="#sjfz">时间复杂度</a>
- <a href="#kjfz">空间复杂度</a>
- 数据结构  
    - <a href="#ljjg">逻辑结构</a>
    - <a href="#ccjg">存储结构</a>
    - <a href="sz">数据结构-数组</a>   
        - 双指针
        - N数之和问题
        - 二维数组
        - 数据统计
    - 数据结构-链表   
        - 基本应用
        - 环类题目
        - 双指针
        - 双向链表
    - 数据结构-二叉树   
        - 二叉树遍历
        - 二叉树的对称性
        - 二叉搜索树
        - 二叉树的深度
    - 数据结构-栈和队列
    - 数据结构-哈希表
    - 数据结构-堆
- 算法
    - 排序
    - 二分查找
    - 递归
        - 重复计算
        - 广度优先搜索
        - 深度优先搜索
        - 回溯算法
        - 动态规划
    - 贪心算法


    ## <a id="ljjg">逻辑结构</a>
    >数据逻辑结构是指数据之间的逻辑关系的描述
    可分为四类基本结构
    - 集合结构：结构中的数据元素之间除了同属一个集合外无任何关系
    - 线性结构：结构中的数据元素存在着一对一的线性关系
    - 树形结构：结构中的数据元素存在着一对多的层次关系
    - 图状结构或网状结构：结构中的数据元素存在着对于多的任意关系

    ## <a id="ccjg">存储结构</a>
    > 逻辑结构在计算机中的存储映像，是逻辑结构在计算机中的实现。它包括数据元素的表示和关系的表示。
    常见的存储结构有
    - 顺序存储：存储位置紧邻
    - 链式存储：逻辑关系紧邻，存储地址不相邻

    ## <a id="sjfz">时间复杂度</a>

    Q： 一枚1元硬币，分为1分、2分、5分硬币共50枚应该如何去分   

    A： 先把公式写出来 `x+y+z=50 x+2y+5z=100`

    ```
    for (let i = 0;i <= 50; i++) {
        for (let j = 0;j <= 50; j++) {
            for (let k = 0;k <= 50; k++) {
                if((i+j+k==50)&&(i+2*j+5*k==100)) {
                    console.log(i, j, k);
                }
            }
        }
    }
    ```
    结果是得到了。但是可以看到此方法用了三重循环，所以基本的判断操作共执行了`51*51*51`次   

    那想要执行次数少些要怎么做那

    ```
    for (let i = 0; i <= 50; i++) {
        for(let j = 0; j <= 50; j++) {
            let k = 50 - i - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }
    ```

    第二种方法总共执行了`51*51`次，明显运行频率要低于第一种，但还是存在着优化的空间

    先梳理下思路，因为是1元硬币所以5分硬币不会超过20个

    ```
    for(let k = 0; k <= 20; k++) {
        for(let j = 0; j <= 50; j++) {
            let i = 50 - k - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }

    ```

    此次循环次数为`21 * 51`次，又提高了运行效率，那可不可以只循环一次那   
    思路：根据 `x+y+z=50 x+2y+5z=100` 可得 y+4z = 50; 并且z最大不能超过12
    ```
    for(let k = 0; k < 13; k++) {
        let j = 50 - 4*k;
        let i = 50 - k - j;
        if((i+j+k==50)&&(i+2*j+5*k==100)) {
            console.log(i, j, k);
        }
    }
    ```

    此时循环次数为13  
    根据以上案例可以得出规律，所有代码的执行时间与每行代码的执行次数成正比
    用公式表达为`T(n) = O(f(n))`   
    其中`T(n)`代表代码执行的时间，`n`表示数据规模的大小，`f(n)`表示每行代码执行的次数总和，
    因为是个公式所以用f(n)来表示。该公式中的`O`表示代码的执行时间T(n)与f(n)表达式成正比。      
    需要注意的是大O时间复杂度不具体表示代码真正的执行时间，而是表示代码的执行时间随数据的规模增长的变化趋势，所以也叫渐进时间复杂度，简称为时间复杂度，要认清`T(n) = O(1)`并不是代码只执行了一次 。         
    由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项   
    
    对于上述例子中第一种三重循环对应的时间复杂度为O(n³);   
    二重循环的时间复杂度为O(n^2)   
    单重循环的时间复杂度为O(n)，也叫线性阶。   
    对于没有循环语句的算法，记作O(1)，也称为常数阶   

    可见算法的设计尤为关键。

    再来看几个例子

    ```
    function test(n) {
        for(let i=0; i < 10; i++) {
            console.log(i);
        }
        for(let j = 0; j < n; j++) {
            console.log(j)
        }
        for(let z = 0; z < n; z++) {
            for (let x = 0; x < n; x++) {
                console.log(x);
            }
        }
    }
    ```
    在test函数中 可以看到第一个循环的时间复杂度O(1)，是一个常量的执行时间，跟n的规模无关;
    第二个循环的时间复杂度为O(n)
    第三个嵌套循环的时间复杂度为O(n^2)   

    根据这三段代码我们取其中最大的量级，总的时间复杂度为量级最大的时间复杂度O(n^2)

    我们来改变下代码
    ```
        function test(n) {
            for(let i=0; i < n; i++) {
            var sum = i + test2(i);
                console.log(sum);
            }
        }
        function test2(n) {
            let sum = 0;
            for(let i=0; i < n; i++) {
                sum = i + sum;
            }
            return sum;
        }
    ```
    在test函数中 如果test2只是一个简单操作，那么test中的for循环的时间复杂度为O(n).      
    但test2并不是一个简单操作，他的时间复杂的为O(n),所以整个test的时间复杂度需要相乘为O(n^2)

    知识补充：   
    - 最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。   
    比如一个数组，我们查找的某个元素刚好是数组的第一个元素，此时的时间复杂度就为O(1)   
    - 最坏时间复杂度：与最好时间度相反, 如上个例子中刚好我们想要的元素在数组的最后一位，需要我们把整个数组都遍历才能找到

    ## <a id="kjfz">空间复杂度</a>   
    空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。
    ```
    function test(n) {
        var i = 0;
        var j = new Array(n);
    }
    ```
    在此段代码中申请了空间存储变量i，但是它是常量阶的，跟数据规模n没有关系所以空间复杂度为O(1)    
    接下来我们申请了大小为n的数组，所以整段代码的空间复杂度为O(n)   
    空间复杂度分析比时间复杂度分析要简单的多，所以这里不再过多举例陈述。明白其中的概念意义即可。


    ## <a id="sz">数组</a>
    提到数组我们一定觉得很熟悉，数组并不只是一种数据类型，他还是一种最基础的数据结构。
    >数组（array）是一种线性表数据结构，它用一组连续的内存空间来存储一组具有相同类型的数据。  

    <font color=#0099ff>Q：什么是线性表？</font>      
    A：线性表是数据数据排成一条线一样的数据结构，每个线性表上的数据最多只有向前和向后两个方向，线性表结构还包含链表、队列、栈等等。   
    <font color=#0099ff>Q：什么是非线性表？ </font>     
    A：非线性表的概念与线性表对立，数据之间并不是单纯的前后关系，如图、堆、二叉树等等   
    <font color=#0099ff>Q：为什么数组要从0开始编号，而不是从1开始？ </font>    
    A：首先需要了解的概念是计算机会为每个内存单元分配地址，然后通过这个地址来访问内存中的数据。   
       当计算机访问数组中的某个元素时会根据寻找公式`a[i]_address = base_address + i * data_type_size`   
       其中`data_type_address`表示数组中每个元素的大小，`base_address`为数组的首地址，可以将下标理解为偏移   
       a[0]是偏移为0的地址，所以为首地址，a[k]就是偏移为k个type_size的地址，当数组从1开始公式就变为 `base_address + (k - 1) * data_type_size`   
       对cpu来说多了一次减法操作

    ### 数组的查找

    因为数组是用连续的内存空间来存储一组具有相同类型的数据，所以支持数据的随机访问。   
    需要注意的是，当我们根据`下标`来查找时，时间复杂度才为O(1).   
    所以不能一竿子打死认为因为数组支持随机访问，所以数组查找的时间复杂度就为O(1), 这种表述是错误的。 

    ### 数组的插入和删除
    一个长度为n的数组，插入元素n，如果从数组的尾部插入则时间复杂度为O(1)(最好时间复杂度)   
    如果从表头插入，为了内存的连续性所有的元素都需要后移一位，所以时间复杂度为O(n)(最坏时间复杂度)

        






## 优秀博文

<a href="https://juejin.im/post/5d5b307b5188253da24d3cd1">前端该如何准备数据结构和算法</a>   
<a href="https://juejin.im/post/5cd1ab3df265da03587c142a?utm_source=gold_browser_extension#heading-7">窥探数据结构的世界</a>
