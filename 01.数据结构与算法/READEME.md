## 数据结构与算法
- 时间复杂度
- <a href="#sjfz">空间复杂度</a>
- 数据结构  
    - <a href="#ljjg">逻辑结构</a>
    - <a href="#ccjg">存储结构</a>
    - 数据结构-二叉树   
        - 二叉树遍历
        - 二叉树的对称性
        - 二叉搜索树
        - 二叉树的深度
    - 数据结构-链表   
        - 基本应用
        - 环类题目
        - 双指针
        - 双向链表
    - 数据结构-数组   
        - 双指针
        - N数之和问题
        - 二维数组
        - 数据统计
    - 数据结构-栈和队列
    - 数据结构-哈希表
    - 数据结构-堆
- 算法
    - 排序
    - 二分查找
    - 递归
        - 重复计算
        - 广度优先搜索
        - 深度优先搜索
        - 回溯算法
        - 动态规划
    - 贪心算法


    <a id="ljjg">逻辑结构</a>
    >数据逻辑结构是指数据之间的逻辑关系的描述
    可分为四类基本结构
    - 集合结构：结构中的数据元素之间除了同属一个集合外无任何关系
    - 线性结构：结构中的数据元素存在着一对一的线性关系
    - 树形结构：结构中的数据元素存在着一对多的层次关系
    - 图状结构或网状结构：结构中的数据元素存在着对于多的任意关系

    <a id="ccjg">存储结构</a>
    > 逻辑结构在计算机中的存储映像，是逻辑结构在计算机中的实现。它包括数据元素的表示和关系的表示。
    常见的存储结构有
    - 顺序存储：存储位置紧邻
    - 链式存储：逻辑关系紧邻，存储地址不相邻

    <a id="sjfz">时间复杂度</a>

    Q： 一枚1元硬币，分为1分、2分、5分硬币共50分应该如何去分   

    A： 先把公式写出来 `x+y+z=50 x+2y+5z=100`

    ```
    for (let i = 0;i <= 50; i++) {
        for (let j = 0;j <= 50; j++) {
            for (let k = 0;k <= 50; k++) {
                if((i+j+k==50)&&(i+2*j+5*k==100)) {
                    console.log(i, j, k);
                }
            }
        }
    }
    ```
    结果是得到了。但是可以看到此方法用了三重循环，所以基本的判断操作共执行了`51*51*51`次   

    那想要执行次数少些要怎么做那

    ```
    for (let i = 0; i <= 50; i++) {
        for(let j = 0; j <= 50; j++) {
            let k = 50 - i - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }
    ```

    第二种方法总共执行了`51*51`次，明显运行时间要低于第一种，但还是存在着优化的空间

    先梳理下思路，因为是1元硬币所以5分硬币不会超过20个

    ```
    for(let k = 0; k <= 20; k++) {
        for(let j = 0; j <= 50; j++) {
            let i = 50 - k - j;
            if((i+j+k==50)&&(i+2*j+5*k==100)) {
                console.log(i, j, k);
            }
        }
    }

    ```

    此次循环次数为`21 * 51`次，又提高了运行效率，那可不可以只循环一次那   
    思路：根据 `x+y+z=50 x+2y+5z=100` 可得 y+4z = 50; 并且z最大不能超过12
    ```
    for(let k = 0; k < 13; k++) {
        let j = 50 - 4*k;
        let i = 50 - k - j;
        if((i+j+k==50)&&(i+2*j+5*k==100)) {
            console.log(i, j, k);
        }
    }
    ```

    此时循环次数为13  
    时间复杂度通俗来讲就是算法执行的时间，一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 
    >算法中基本语句重复执行的次数是问题规模n（即问题的大小）的某一个函数f(n),算法的时间量度记作：T(n)=O(f(n))表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐近时间复杂度。

    对于上述例子中第一种三重写法对应的时间复杂度为O(n³);   
    对于二重循环的时间复杂度为O(n^2)   
    单重循环的时间负责度为O(n)，也叫线性阶。   
    对于没有循环语句的算法，记作O(1)，也称为常数阶   

    所以算法的设计尤为关键